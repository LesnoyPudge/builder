class CacheLayer {
    data = {
        isComputed: false,
        value: undefined,
        cleanupTimeoutId: null,
    };
    map;
    getOrCreateMap() {
        if (!this.map) {
            this.map = new Map();
        }
        return this.map;
    }
    setValue(value, lifespan) {
        if (this.data.cleanupTimeoutId !== null) {
            clearTimeout(this.data.cleanupTimeoutId);
        }
        this.data.isComputed = true;
        this.data.value = value;
        if (lifespan !== Infinity) {
            this.data.cleanupTimeoutId = setTimeout(() => {
                this.data.isComputed = false;
                this.data.value = undefined;
                this.data.cleanupTimeoutId = null;
            }, lifespan);
        }
        return value;
    }
}
export class Cache {
    layer;
    getOrCreateLayer(key) {
        if (!this.layer) {
            this.layer = new CacheLayer();
        }
        let currentLayer = this.layer;
        key.forEach((keyPart) => {
            const map = currentLayer.getOrCreateMap();
            const layer = map.get(keyPart);
            if (!layer) {
                currentLayer = new CacheLayer();
                map.set(keyPart, currentLayer);
                return;
            }
            currentLayer = layer;
        });
        return currentLayer;
    }
    getLayer(key) {
        let currentLayer = this.layer;
        if (!this.layer)
            return undefined;
        const bail = () => {
            currentLayer = undefined;
        };
        key.forEach((keyPart) => {
            if (!currentLayer)
                return bail();
            const map = currentLayer.map;
            if (!map)
                return bail();
            if (!map.has(keyPart))
                return bail();
            currentLayer = map.get(keyPart);
        });
        return currentLayer;
    }
    has(key) {
        return !!this.getLayer(key)?.data.isComputed;
    }
    set(key, value, lifespan = Infinity) {
        return this.getOrCreateLayer(key).setValue(value, lifespan);
    }
    get(key) {
        return this.getLayer(key)?.data.value;
    }
    getOrSet(key, getNewValueIfEmpty, lifespan = Infinity) {
        const layer = this.getOrCreateLayer(key);
        if (layer.data.isComputed)
            return layer.data.value;
        return layer.setValue(getNewValueIfEmpty(), lifespan);
    }
    getSize() {
        let size = 0;
        if (this.layer?.data.isComputed) {
            size++;
        }
        const loop = (layer) => {
            if (!layer)
                return;
            if (!layer.map)
                return;
            size += layer.map.size;
            layer.map.forEach(loop);
        };
        loop(this.layer);
        return size;
    }
    destroy() {
        this.layer = undefined;
    }
}
//# sourceMappingURL=Cache.js.map