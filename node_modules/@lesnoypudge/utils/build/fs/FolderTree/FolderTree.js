import { autoBind } from '../../index.js';
import fs from 'node:fs';
import path from 'node:path';
export class FolderTree {
    data;
    constructor(providedPath, extensions) {
        this.data = this.createFolderTree(providedPath, extensions);
        autoBind(this);
    }
    createFolderTree(providedPath, extensions) {
        try {
            const resolvedPath = path.resolve(import.meta.dirname, providedPath);
            const currentStats = fs.statSync(resolvedPath);
            const tree = this.createEmptyFolder('', resolvedPath);
            if (currentStats.isDirectory()) {
                tree.name = path.basename(resolvedPath);
            }
            this.fillFolder(resolvedPath, tree, extensions);
            return tree;
        }
        catch (error) {
            return null;
        }
    }
    createEmptyFolder(name, path) {
        return {
            type: 'folder',
            files: [],
            folders: [],
            name,
            path,
        };
    }
    fillFolder(currentPath, folder, extensions) {
        const files = fs.readdirSync(currentPath);
        files.forEach((fileName) => {
            const filePath = path.join(currentPath, fileName);
            const stat = fs.statSync(filePath);
            const validExtension = (extensions
                ? extensions.some((ext) => fileName.endsWith(ext))
                : true);
            if (stat.isFile() && validExtension) {
                const fileData = fs.readFileSync(filePath);
                folder.files.push({
                    data: fileData,
                    name: fileName,
                    type: 'file',
                    path: filePath,
                });
            }
            if (stat.isDirectory()) {
                const newFolder = this.createEmptyFolder(fileName, filePath);
                folder.folders.push(newFolder);
                this.fillFolder(filePath, newFolder, extensions);
            }
        });
    }
    traverseFolder(folder, cb) {
        cb(folder);
        folder.files.forEach(cb);
        folder.folders.forEach((_folder) => {
            this.traverseFolder(_folder, cb);
        });
    }
    traverse(cb) {
        if (!this.data)
            return;
        this.traverseFolder(this.data, cb);
    }
    isEmpty() {
        return !(this.data?.files.length ?? this.data?.folders.length);
    }
    getDataWithoutBuffer() {
        if (!this.data)
            return this.data;
        const folder = structuredClone(this.data);
        this.traverseFolder(folder, (fileOrFolder) => {
            if (fileOrFolder.type !== 'file')
                return;
            fileOrFolder.data = Buffer.from('');
        });
        return folder;
    }
}
//# sourceMappingURL=FolderTree.js.map